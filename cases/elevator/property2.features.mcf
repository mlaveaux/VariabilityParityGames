% property 1
% AG (liftBut_i.pressed -> AF (lift.Level = i & lift.door = open) )
% invariantly, if a landing button is pressed at Level i, the lift will inevitably open its doors on Level i

%nu X. [true]X && forall i:Floor. [liftButton(i)](mu Y. [!open(i)]Y && <true>true )

% fails exactly when either:
% - executive feature enabled because the lift may ping-pong between two storeys and never stop at the storey in
%   which the landing button is pressed
% - empty carriage feature enabled because someone may play pranks on the elevator by infinitely often pressing
%   and cancelling a lift button
% - overload feature enabled because the lift disables these buttons when an overload is detected

(nu X (Px:FExpr = normalise( neg(or(atom(EC), or(atom(O),or(atom(TTF),atom(Ex) ) ) ) ))).  % this one yields 'true'
  ( 
  %  translate [true]X
    
     [exists i:Floor. landingButton(i)] X(Px)
  && [exists i:Floor. liftButton(i)] X(Px)
  && [exists i:Floor. open(i)] X(Px)
  && [exists i:Floor. Level(i)] X(Px)
  && [exists d:Direction. direction(d)] X(Px)
  && [close] X(Px)
  && (forall e:FExpr. [exists i:Floor. executive(e,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  && (forall e:FExpr. [exists a:Alarm. overload(e,a)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  && (forall e:FExpr. [parking(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  && (forall e:FExpr. [empty(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt)))) ) )
  
  &&
  % translate forall i:Floor. [liftButton(i)](mu Y. [!open(i)]Y && <true>true )
  forall j:Floor. 
    (
    % translate [liftButton(j)](mu Y. [!open(j)]Y && <true>true )
    [liftButton(j)]
      (
      % translate (mu Y. [!open(j)]Y && <true>true )
      mu Y(Py:FExpr = Px).
        (
        % translate [!open(j)]Y && <true>true 
          (
            [exists i:Floor. landingButton(i)] Y(Py)
         && [exists i:Floor. liftButton(i)] Y(Py)
         && [!open(j) && exists i:Floor. open(i)] Y(Py)
         && [exists i:Floor. Level(i)] Y(Py)
         && [exists d:Direction. direction(d)] Y(Py)
         && [close] Y(Py)
         && (forall e:FExpr. [exists i:Floor. executive(e,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
         && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
         && (forall e:FExpr. [exists a:Alarm. overload(e,a)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
         && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
         && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
         && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))) ) ) )
          )
        &&
          (
            <exists i:Floor. landingButton(i)> true
         || <exists i:Floor. liftButton(i)> true
         || <exists i:Floor. open(i)> true
         || <exists i:Floor. Level(i)> true
         || <exists d:Direction. direction(d)> true
         || <close> true
         || (exists e:FExpr. <exists i:Floor. executive(e,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <exists a:Alarm. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
          )
        )
      )
  
    )
  )
)

&&

% Now for the reverse for the remaining features:
% mu X. <true>X || exists i:Floor. <liftButton(i)>(nu Y. <!open(i)>Y || [true]false )

forall Fx:FExpr.  val(Fx in [atom(Ex), atom(O), atom(EC)]) =>
(mu X (Px:FExpr = normalise( Fx)).  % this one yields 'true' (hopefully)
  ( 
  %  translate <true>X
    
     <exists i:Floor. landingButton(i)> X(Px)
  || <exists i:Floor. liftButton(i)> X(Px)
  || <exists i:Floor. open(i)> X(Px)
  || <exists i:Floor. Level(i)> X(Px)
  || <exists d:Direction. direction(d)> X(Px)
  || <close> X(Px)
  || (exists e:FExpr. <exists i:Floor. executive(e,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  || (exists e:FExpr. <exists a:Alarm. overload(e,a)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px) ) )
  
  ||
  % translate exists j:Floor. <liftButton(j)>(nu Y. <!open(j)>Y || [true]false )
  exists j:Floor. 
    (
    % translate <liftButton(j)>(nu Y. <!open(j)>Y || [true]false )
    <liftButton(j)>
      (
      % translate (nu Y. <!open(j)>Y || [true]false )
      nu Y(Py:FExpr = Px).
        (
        % translate <!open(j)>Y || [true]false 
          (
            <exists i:Floor. landingButton(i)> Y(Py)
         || <exists i:Floor. liftButton(i)> Y(Py)
         || <!open(j) && exists i:Floor. open(i)> Y(Py)
         || <exists i:Floor. Level(i)> Y(Py)
         || <exists d:Direction. direction(d)> Y(Py)
         || <close> Y(Py)
         || (exists e:FExpr. <exists i:Floor. executive(e,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
         || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
         || (exists e:FExpr. <exists a:Alarm. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
         || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
         || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
         || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
          )
        ||
          (
            [exists i:Floor. landingButton(i)] false
         && [exists i:Floor. liftButton(i)] false
         && [exists i:Floor. open(i)] false
         && [exists i:Floor. Level(i)] false
         && [exists d:Direction. direction(d)] false
         && [close] false
         && (forall e:FExpr. [exists i:Floor. executive(e,i)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [exists a:Alarm. overload(e,a)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, e)) == ff)  ) )
  
          )
        )
      )
  
    )
  )
)
