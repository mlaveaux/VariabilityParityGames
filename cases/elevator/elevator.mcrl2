sort
  Door = struct open | closed;
  Direction = struct up | down;
  Floor = Nat;
  Buttons = Floor -> Bool;
  Alarm = struct on | off;

map
  no_dest : Buttons; 
  call : Direction # Floor # Buttons -> Floor;
  door_function : Floor # Floor # Floor -> Door;
  idle : Buttons # Buttons -> Bool;
  idle : Buttons -> Bool;

  next_floor     : Floor # Door # Direction # Buttons # Buttons -> Floor;
  next_direction : Floor # Door # Direction # Buttons # Buttons -> Direction;
  
% more elegant, but turns out to slow down state space generation
% eqn
%   no_dest = lambda n:Nat. false;

var
  n:Nat;
eqn
  no_dest(n) = false;

var
  d:Direction;
  f,f1,f2,f3:Floor;
  l,l1,l2:Buttons;
  d':Door;
eqn
  (d == down) -> call(d,f,l) =  if(l(5) && f > 4, 5,
                                  if(l(4) && f > 3, 4,
                                    if(l(3) && f > 2, 3,
                                      if(l(2) && f > 1, 2,
                                        if(l(1), 1, 0 ) ) ) ) );

  (d == up)   -> call(d,f,l) =  if(l(1) && f < 2, 1,
                                  if(l(2) && f < 3, 2,
                                    if(l(3) && f < 4, 3,
                                      if(l(4) && f < 5, 4,
                                        if(l(5), 5, 0 ) ) ) ) );

  f1 == f2 -> door_function(f1,f2,f3) = open;
  f1 == f3 -> door_function(f1,f2,f3) = open;
  f1 != f2 && f1 != f3 -> door_function(f1,f2,f3) = closed;

  % more generic but marginally slower...
  %idle(l1,l2) = forall i:Nat. (l1(i) == false && l2(i) == false);

  idle(l) = l(1) == false && l(2) == false && l(3) == false && l(4) == false && l(5) == false;
  idle(l1,l2) = idle(l1) && idle(l2);
  %idle(l1,l2) = l1(1) == false && l1(2) == false && l1(3) == false && l1(4) == false && l1(5) == false &&
  %              l2(1) == false && l2(2) == false && l2(3) == false && l2(4) == false && l2(5) == false;

  % l1 is liftbuttons; l2 is landingbuttons
  next_floor(f,d',d,l1,l2) = if(d' == open, f,
                             if(call(d,f,l1) == 0 && call(d,f,l2) == 0, f,
                                if(d == up && f < 5, f+1,
                                  if(d == down && f > 1, Int2Nat(f-1), f)
                                  )
                                )
                             );

  next_direction(f,d',d,l1,l2) = if(idle(l1,l2), d,
                                if(f == 5, down,
                                  if(f == 1, up,
                                    if(call(d,f,l1) == 0 && call(d,f,l2) == 0 && d == down, up,
                                      if(call(d,f,l1) == 0 && call(d,f,l2) == 0 && d == up, down, d)
                                      )
                                    )
                                  )
                                );

act
 landingButton, liftButton, open,idling,floor, executive : Floor;
 direction : Direction;
 overload: Alarm;
 close; parking; ttfull; empty;


proc Lift(floor:Floor, door:Door, direction:Direction, liftbuttons,storedliftbuttons:Buttons, landingbuttons,storedlandingbuttons:Buttons, parking:Bool, ttfull:Bool, overload:Bool, executive:Floor)
=

% special treatment of landingbutton 1 in case we're in parking mode but still  on some floor different from floor 1;
% in that case, we can switch to non-parking mode in case someone presses the landing button on floor 1
( (parking && floor != 1) -> landingButton(1). Lift(parking = false) )
+
% detecting buttons in case the executive mode is off
sum i: Nat. (1 <= i && i <= 5 && executive == 0) -> 
  % first deal with the landing buttons
( (!landingbuttons(i) && !ttfull) ->     % allow for button presses if 'floor' differs 'i'; note that property 1 is violated 
                                         % if we weaken this to either 'floor' differs 'i', or the door is closed
                                         % also, if the elevator is two-thirds full, ignore all landing button presses
                           ( !parking -> ( (floor != i) -> landingButton(i) . Lift(landingbuttons = landingbuttons[i -> true], parking = false ) )
                                      <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                                         ( (floor != i) -> landingButton(i) . Lift(landingbuttons = (landingbuttons[1 ->false])[i -> true], parking = false ) )
              )
+
  % take care of the carriage buttons
  (!liftbuttons(i) && floor != i) ->  % allow for lift button presses; alternatively, we could strengthen this to '!parking', but
                                      % since in our current implementation the doors remain open when idling, someone could have entered
                                      % the lift, so these buttons can be pressed
              ( !parking  -> liftButton(i). Lift(liftbuttons = liftbuttons[i -> true] )
                          <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                             liftButton(i). Lift(landingbuttons = landingbuttons[1 -> false], liftbuttons = liftbuttons[i -> true], parking = false )
              )

+ 
  % a big cheese presses a landing button on floor 'i'; store all calls and rush to the i-th floor; 
  % at the same time, override the parking bit (if it was set) and the landing button on floor 1. 
  % Cache all lift buttons and landing buttons 
  (floor != i) ->
               ( !parking ->  executive(i). Lift(storedliftbuttons = liftbuttons[i -> false], storedlandingbuttons = landingbuttons[i -> false], liftbuttons = no_dest, landingbuttons = no_dest[i -> true], executive = i) 
                          <> % switch to non-parking mode, unset the landing button on floor 1, store the lift and landing buttons
                             executive(i). Lift(storedliftbuttons = no_dest, storedlandingbuttons = no_dest, liftbuttons = no_dest, landingbuttons = no_dest[i -> true], executive = i, parking = false) 
               )
)

+
  % detecting buttons, now for the case the executive button has been pressed
  % this means all calls get recorded in the storedliftbuttons and storedlandingbuttons;
  % this seems to deviate from Plath and Ryan, which simply seem to ignore any of these
  % button presses if I understand their model correctly
sum i: Nat. (1 <= i && i <= 5 && executive != 0) -> 
( (!storedlandingbuttons(i) && !ttfull) ->     % allow for button presses if 'floor' differs 'i'; note that property 1 is violated 
                                               % if we weaken this to either 'floor' differs 'i', or the door is closed
                                               % also, if the elevator is two-thirds full, ignore all landing button presses
                                 ( !parking -> ( (floor != i && i != executive) -> landingButton(i) . Lift(storedlandingbuttons = storedlandingbuttons[i -> true], parking = false ) )
                                            <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                                               ( (floor != i && i != executive) -> landingButton(i) . Lift(storedlandingbuttons = (storedlandingbuttons[1 ->false])[i -> true], parking = false ) )
                   )
+
  (!liftbuttons(i) && floor != i && executive != i) ->  % allow for lift button presses; alternatively, we could strengthen this to '!parking', but
                                                        % since in our current implementation the doors remain open when idling, someone could have entered
                                                        % the lift, so these buttons can be pressed
                                ( !parking  -> liftButton(i). Lift(storedliftbuttons = storedliftbuttons[i -> true] )
                                            <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                                               liftButton(i). Lift(storedlandingbuttons = storedlandingbuttons[1 -> false], storedliftbuttons = storedliftbuttons[i -> true], parking = false )
                                )
)
+

  % now for the opening/closing of the door; this takes priority over changing direction
  % or moving. If the door does not change, then we can check where to move to next, 
  % or whether we must change direction
  
sum d':Door. ( d' == door_function(floor, call(direction,floor,liftbuttons), call(direction,floor,landingbuttons)  ) ) ->
(
  (d' != door ) ->
      ( % the new status  of the door is that it should open.
        (d' == open) ->
                     (
                      (executive == 0) -> open(floor). Lift (door = d', liftbuttons = liftbuttons[floor -> false], landingbuttons = landingbuttons[floor -> false], parking = false, ttfull= false )
                                       <> % there was a big cheese on 'floor'; load the guy and restore all buttons as pressed earlier
                                          open(floor). Lift (door = d', liftbuttons = storedliftbuttons, landingbuttons = storedlandingbuttons, storedliftbuttons = no_dest, storedlandingbuttons = no_dest, parking = false, ttfull= false, executive = 0 )

                      + % if the elevator is two-thirds full and some people remain in the carriage, it can remain two-thirds full
                        (ttfull && !idle(liftbuttons[floor -> false])) -> open(floor). Lift (door = d', liftbuttons = liftbuttons[floor -> false], landingbuttons = landingbuttons[floor -> false], parking = false )
                     )
       <> % the new status of the door is that it should close.
                     (
                      % we can close the door if the lift is not in overload and some button was pressed
                        (
                          (!overload) -> 
                                         (!idle(liftbuttons,landingbuttons)) -> close. Lift (door = d')
                                       + % if the two-thirds full feature is enabled, we can even close the door and we cancel all landingbuttons
                                         % provided, of course, that there is some button that was pressed in the carriage itself
                                         (!idle(liftbuttons)) -> ttfull. close.  Lift (door = d', landingbuttons = no_dest, ttfull = true)
                         )
                    + % we have the empty detector, which cancels all carriage buttons in case there were only prank calls
                      (!idle(liftbuttons) && !overload) -> empty. Lift (liftbuttons = no_dest)
                    + % we have the overload detection, which toggles whether the carriage is too full
                      (!idle(liftbuttons) && !overload) -> overload(on). Lift(overload = !overload)
                    + (!idle(liftbuttons) && overload) -> overload(off). Lift(overload = !overload)
                    + % we have the parking detector, which parks the carriage in case there are no calls
                      (idle(liftbuttons,landingbuttons) && floor != 1) -> parking. Lift (landingbuttons = landingbuttons[1 -> true],  parking = true)
                    + % we have this idle loop just to signify the passage of time in case there is nothing happening;
                      % needed for verifying requirement 4 in Plath & Ryan
                     (idle(liftbuttons,landingbuttons)) -> idling(floor). Lift ()
                     )
       )
  <>  % there is no reason to change status of the door, so we can start moving
     ( 
      sum f:Floor.  (f == next_floor(floor,door,direction,liftbuttons,landingbuttons) ) ->
        ( % f is the next floor; if it differs from the current floor, we move there
          (floor != f) -> floor(f). Lift(floor = f)
                       <>  % apparently, we didn't change floors; perhaps we first need to change direction
                          ( sum d:Direction. (d == next_direction(floor,door,direction,liftbuttons,landingbuttons) ) ->
                            (d != direction) -> direction(d). Lift(direction = d)
                          )
        )
     )
)
;

init Lift(1, open, down,no_dest,no_dest,no_dest,no_dest,false,false,false,0);
