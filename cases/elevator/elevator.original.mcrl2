sort
  Door = struct open | closed;
  Direction = struct up | down;
  Floor = Nat;
  Buttons = Floor -> Bool;
  Signal = struct on | off;

map
  no_dest : Buttons; 
  call : Direction # Floor # Buttons -> Floor;
  door_function : Floor # Floor # Floor -> Door;
  idle : Buttons # Buttons -> Bool;
  idle : Buttons -> Bool;
  priority_call : Floor # Floor # Direction # Buttons -> Floor;

  next_floor     : Floor # Floor # Door # Direction # Buttons # Buttons -> Floor;
  next_direction : Floor # Floor # Direction # Buttons # Buttons -> Direction;
  
% more elegant, but turns out to slow down state space generation
% eqn
%   no_dest = lambda n:Nat. false;

var
  n:Nat;
eqn
  no_dest(n) = false;

var
  d:Direction;
  f,f1,f2,f3:Floor;
  l,l1,l2:Buttons;
  d':Door;
eqn
  (d == down) -> call(d,f,l) =  if(l(5) && f > 4, 5,
                                  if(l(4) && f > 3, 4,
                                    if(l(3) && f > 2, 3,
                                      if(l(2) && f > 1, 2,
                                        if(l(1), 1, 0 ) ) ) ) );

  (d == up)   -> call(d,f,l) =  if(l(1) && f < 2, 1,
                                  if(l(2) && f < 3, 2,
                                    if(l(3) && f < 4, 3,
                                      if(l(4) && f < 5, 4,
                                        if(l(5), 5, 0 ) ) ) ) );

  f1 == f2 -> door_function(f1,f2,f3) = open;
  f1 == f3 -> door_function(f1,f2,f3) = open;
  f1 != f2 && f1 != f3 -> door_function(f1,f2,f3) = closed;

  % more generic but marginally slower...
  %idle(l1,l2) = forall i:Nat. (l1(i) == false && l2(i) == false);

  idle(l) = l(1) == false && l(2) == false && l(3) == false && l(4) == false && l(5) == false;
  idle(l1,l2) = idle(l1) && idle(l2);
  %idle(l1,l2) = l1(1) == false && l1(2) == false && l1(3) == false && l1(4) == false && l1(5) == false &&
  %              l2(1) == false && l2(2) == false && l2(3) == false && l2(4) == false && l2(5) == false;

  % l1 is liftbuttons; l2 is landingbuttons
  next_floor(f1,f2,d',d,l1,l2) = if(d' == open, f2,
                             if(call(d,f2,l1) == 0 && priority_call(f1,f2,d,l2) == 0, f2,
                                if(d == up && f2 < 5, f2+1,
                                  if(d == down && f2 > 1, Int2Nat(f2-1), f2)
                                  )
                                )
                             );

  next_direction(f1,f2,d,l1,l2) = if(idle(l1,l2), d,
                                     if(f2 == 5, down,
                                       if(f2 == 1, up,
                                         if(call(d,f2,l1) == 0 && priority_call(f1,f2,d,l2) == 0 && d == down, up,
                                           if(call(d,f2,l1) == 0 && priority_call(f1,f2,d,l2) == 0 && d == up, down, d)
                                           )
                                         )
                                       )
                                     );

  priority_call(f1,f2,d,l) = if(f1 == 1 && l(f1), 1,
                               if(f1 == 2 && l(f1), 2,
                                 if(f1 == 3 && l(f1), 3,
                                   if(f1 == 4 && l(f1), 4,
                                     if(f1 == 5 && l(f1), 5, call(d,f2,l)
                                       )
                                     )
                                   )
                                 )
                               );

act
 landingButton, liftButton, open,idling,floor : Floor;
 executive : Signal # Floor; executive : Signal;
 direction : Direction;
 overload: Signal;
 close; parking; ttfull; empty;


proc Lift(floor:Floor, door:Door, direction:Direction, liftbuttons,landingbuttons:Buttons, parking:Bool, ttfull:Bool, overload:Bool, executive:Floor)
=

% special treatment of landingbutton 1 in case we're in parking mode but still  on some floor different from floor 1;
% in that case, we can switch to non-parking mode in case someone presses the landing button on floor 1
( (parking && floor != 1) -> landingButton(1). Lift(parking = false) )
+
% detecting buttons in case the executive mode is off
sum i: Nat. (1 <= i && i <= 5) -> 
  % first deal with the landing buttons
( (!landingbuttons(i) && !ttfull) ->     % allow for button presses if 'floor' differs 'i'; note that property 1 is violated 
                                         % if we weaken this to either 'floor' differs 'i', or the door is closed
                                         % also, if the elevator is two-thirds full, ignore all landing button presses
                                         % moreover, pressing the landing button on the executive floor cancels the lift buttons (sorry guys)
                           ( !parking -> ( (i != executive && (floor != i || door == closed)) -> landingButton(i) . Lift(landingbuttons = landingbuttons[i -> true], parking = false ) 
                                         + (i == executive && (floor != i || door == closed)) -> landingButton(i) . Lift(liftbuttons = no_dest, landingbuttons = landingbuttons[i -> true], parking = false ) 
                                         )
                                      <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                                         ( (i != executive && (floor != i || door == closed)) -> landingButton(i) . Lift(landingbuttons = (landingbuttons[1 ->false])[i -> true], parking = false ) 
                                         + (i == executive && (floor != i || door == closed)) -> landingButton(i) . Lift(landingbuttons = (landingbuttons[1 ->false])[i -> true], parking = false ) 
                                         )
              )
+
  % take care of the carriage buttons; only register these if there's no big chees on the executive floor
  (!liftbuttons(i) && floor != i && 
    (executive > 0 => landingbuttons(executive) == false)) ->  % allow for lift button presses; alternatively, we could strengthen this to '!parking', but
                                                               % since in our current implementation the doors remain open when idling, someone could have entered
                                                               % the lift, so these buttons can be pressed
                                       ( !parking  -> liftButton(i). Lift(liftbuttons = liftbuttons[i -> true] )
                                                   <> % switch to non-parking mode, unset the landing button on floor 1 and then set the landing button on floor i
                                                      liftButton(i). Lift(landingbuttons = landingbuttons[1 -> false], liftbuttons = liftbuttons[i -> true], parking = false )
                                       )

+ 
  % designate floor i as executive floor; whenever a landing button on that floor is pressed, we
  % need to cancel all lift buttons and rush to the designated floor;
  (executive == 0) -> executive(on,i). Lift(executive = i)  <> executive(off). Lift(executive = 0)
)

+

  % now for the opening/closing of the door; this takes priority over changing direction
  % or moving. If the door does not change, then we can check where to move to next, 
  % or whether we must change direction
  
sum d':Door. ( d' == door_function(floor, call(direction,floor,liftbuttons), priority_call(executive,floor,direction,landingbuttons)  ) ) ->
(
  (d' != door ) ->
      ( % the new status  of the door is that it should open.
        (d' == open) ->
                     (
                        open(floor). Lift (door = d', liftbuttons = liftbuttons[floor -> false], landingbuttons = landingbuttons[floor -> false], parking = false, ttfull= false )
                      + % if the elevator is two-thirds full and some people remain in the carriage, it can remain two-thirds full
                        (ttfull && !idle(liftbuttons[floor -> false])) -> open(floor). Lift (door = d', liftbuttons = liftbuttons[floor -> false], landingbuttons = landingbuttons[floor -> false], parking = false )
                     )
       <> % the new status of the door is that it should close.
                     (
                      % we can close the door if the lift is not in overload and some button was pressed
                        (
                          (!overload) -> 
                                         close. Lift (door = d')
                                       + % if the two-thirds full feature is enabled, we can even close the door and we cancel all landingbuttons
                                         % provided, of course, that there is some button that was pressed in the carriage itself
                                         (!idle(liftbuttons)) -> ttfull. close.  Lift (door = d', landingbuttons = no_dest, ttfull = true)
                         )
                    + % we have the empty detector, which cancels all carriage buttons in case there were only prank calls
                      (!idle(liftbuttons) && !overload) -> empty. Lift (liftbuttons = no_dest)
                    + % we have the overload detection, which toggles whether the carriage is too full
                      (!idle(liftbuttons) && !overload) -> overload(on). Lift(overload = !overload)
                    + (!idle(liftbuttons) && overload) -> overload(off). Lift(overload = !overload)
                    %+ % we have the parking detector, which parks the carriage in case there are no calls
                    %  (idle(liftbuttons,landingbuttons) && floor != 1) -> parking. Lift (landingbuttons = landingbuttons[1 -> true],  parking = true)
                    %+ % we have this idle loop just to signify the passage of time in case there is nothing happening;
                      % needed for verifying requirement 4 in Plath & Ryan
                     %(idle(liftbuttons,landingbuttons) && door == closed) -> idling(floor). Lift ()
                     )
       )
  <>  % there is no reason to change status of the door, so we can start moving
     ( 
      sum f:Floor.  (f == next_floor(executive,floor,door,direction,liftbuttons,landingbuttons) ) ->
        ( % f is the next floor; if it differs from the current floor, we move there
          (floor != f) -> floor(f). Lift(floor = f)
                       <>  % apparently, we didn't change floors; perhaps we first need to change direction
                          ( sum d:Direction. (d == next_direction(executive,floor,direction,liftbuttons,landingbuttons) ) ->
                            (d != direction) -> direction(d). Lift(direction = d)
                                             <> % nothing changed... so we idle
                                                (idling(floor). Lift ()
                                               +
                                                 (floor != 1) -> parking. Lift (landingbuttons = landingbuttons[1 -> true],  parking = true)
                                                )
                          )
        )
     )
)
;

init Lift(1, open, down,no_dest,no_dest,false,false,false,0);
