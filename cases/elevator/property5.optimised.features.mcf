% property 5
% EF (Level = i & door = closed & idle )
% AG (Level = i & door=closed & idle -> EG(Level = i & door=closed) )
% invariantly, if the lift is idling on Level i, it can remain at Level i

% (forall i:Floor.val(1 <=i && i <=5) =>  <true*. idling(i)>true )
% &&
% [ true*] forall i:Floor. val(1 <= i && i <= 5) =>  [ idling(i) ] nu Y. <idling(i)>Y

(nu X (Px:FExpr = normalise( neg(atom(P) )),door :Door = closed).  % this one yields 'true'
  ( 
  %  translate [true]X
    
     (forall i:Floor. [landingButton(i)] X(Px, door) )
  && (forall i:Floor. [liftButton(i)] X(Px, door) )
  && (forall i:Floor. [open(i)] X(Px, open)  )
  && [exists i:Floor. Level(i)] X(Px,door)
  && [exists d:Direction. direction(d)] X(Px,door)
  && [close] X(Px,closed)
  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (forall e:FExpr. [parking(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (forall e:FExpr. [empty(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),door) ) )
  && (
       (door == closed) =>
         forall e:FExpr. [exists i:Floor. idling(e,i)] 
           (val(normalise(and(Px, and(e,tt))) == ff) ||
             nu Y(Py:FExpr = normalise(and(Px, and(e,tt)))).
             (
             % translate <idling(i)>Y 
              (exists e:FExpr. <exists j:Floor. idling(e,j)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py) ) )
             )
           )
      )
  )
)
 
&& % and now for the complement; here we cannot just say that there is some idle transition that leads to a finite number of idle transitions
   % instead, we'll need to record whether the lift is idle...
   % Technically, it is not 100% correct since when we move from parking to non-parking, the landing button on Level 1 needs to be unset;
   % this is currently not taken into account. On the other hand, if this formula evaluates to 'true', then so would the correct one.

(mu X (Px:FExpr = normalise( atom(P) ), li:Buttons = no_dest,la:Buttons = no_dest,door : Door = closed).  
  ( 
  %  translate <true>X
    (
       (exists i:Floor. <landingButton(i)> X(Px,li,update(la,i,  true),door))
    || (exists i:Floor. <liftButton(i)> X(Px,update(li,i, true), la,door))
    || (exists i: Floor. <open(i)> X(Px, update(li,i, false), update(la,i, false), open ))
    || <exists i:Floor. Level(i)> X(Px,li,la,door)
    || <exists d:Direction. direction(d)> X(Px,li,la,door)
    || <close> X(Px,li,la,closed)
    || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,update(la,1,true),door) ) )   
    || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,la,door) ) )
    || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,la,door) ) )
    || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,la,door) ) )
    || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,la,door) ) )
    || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Px),e)) == tt) && X(Px,li,la,door) ) )
    || (val(idle(li,la) && door == closed ) && mu Y(Py:FExpr = Px).
          (
           (forall e:FExpr. [exists j:Floor. idling(e,j)] (val(normalise(and(Py, e)) == ff) || Y(normalise(and(Py,e)) ) ) )
          )
        )
    )
  )
)
