% property 3
% AG forall i < j. (Level = i & lifBut_j.pressed & direction = up -> A[direction=up U Level = j])
% &
% AG forall i > j. (Level = i & lifBut_j.pressed & direction = down -> A[direction=down U Level = j])
%
% invariantly, if the lift is travelling up (down) while there are calls in that direction it will not change the direction it is travelling
%
% NB: since we (currently) don't have a way to test on which Level we are,
% other than through opening the door, we resort to using that action...
% and we only check that we're moving up (down)

% nu X(fx:Floor = 0, dx:Direction = down). 
%   (
%      [!(exists i:Floor. Level(i)) && !(exists d:Floor. direction(d))]X (fx,dx)
%   &&
%      forall i:Floor. [Level(i)]X(i,dx)
%   &&
%      forall d:Direction. [direction(d)]X(fx,d)
%   &&
%      val(dx == up) =>
%         (
%           forall j:Floor. (val(fx < j && j <= 5) => 
%                 [liftButton(j)] 
%                   (
%                      mu Y. ( [!open(j)]Y && [direction(down)]false && <true>true )
%                   )
%         )
%   &&
%      val(dx == down) =>
%         (
%           forall j:Floor. (val(1 <= j && j < fx ) => 
%                 [liftButton(j)] 
%                   (
%                      mu Y. ( [!open(j)]Y && [direction(up)]false && <true>true )
%                   )
%         )
%   )

(nu X (Px:FExpr = normalise( neg(or(atom(EC), atom(O) ) ) ), fx:Floor = 1, dx:Direction = down, doorx:Door = closed).  % this one yields 'true'
  ( 
  %  translate [true]X
    
     [exists i:Floor. landingButton(i)] X(Px,fx,dx,doorx)
  && [exists i:Floor. liftButton(i)] X(Px,fx,dx,doorx)
  && [exists i:Floor.open(i)] X(Px,fx,dx,open) 
  && (forall i: Floor. [Level(i)] X(Px,i,dx,doorx) )
  && (forall d:Direction. [direction(d)] X(Px,fx,d,doorx) )
  && [close] X(Px,fx,dx,closed)
  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [parking(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )
  && (forall e:FExpr. [empty(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),fx,dx,doorx) ) )

  && (val(dx == up) =>
        (
          forall j:Floor. ( val(fx < j && j <= 5) =>
            [liftButton(j)]
              (
                mu Y(Py:FExpr = Px, fy:Floor = fx, doory:Door = doorx). 
                 (
                   (val(fy == j) )
                 ||
                 (
                 % translate [!open(j)]Y && <true>true 
                   (
                     [!landingButton(fy) && exists i:Floor. landingButton(i)] Y(Py,fy,doory)   % we ignore landing button presses on Level fy
                  && [exists i:Floor. liftButton(i)] Y(Py,fy,doory)
                  && [exists i:Floor. open(i)] Y(Py,fy,open) 
                  && (forall i:Floor. [Level(i)] Y(Py,i,doory) )
                  && [exists d:Direction. direction(d)] Y(Py,fy,doory)
                  && [close] Y(Py,fy,closed)
                  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy,  doory ) ) )
                  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                   )
                 &&
                    ([direction(down)]false)
                 &&
                   (
                     <exists i:Floor. landingButton(i)> true
                  || <exists i:Floor. liftButton(i)> true
                  || <exists i:Floor. open(i)> true
                  || <exists i:Floor. Level(i)> true
                  || <exists d:Direction. direction(d)> true
                  || <close> true
                  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                   )
                 )
                )
              )
            )
        )
      )
   && (val(dx == down) =>
        (
          forall j:Floor. ( val(1 <= j && j <= fx) =>
            [liftButton(j)]
              (
                mu Y(Py:FExpr = Px, fy:Floor = fx, doory:Door = doorx). 
                 (
                   (val(fy == j) )
                 ||
                 (
                 % translate [!open(j)]Y && <true>true 
                   (
                     [!landingButton(fy) && exists i:Floor. landingButton(i)] Y(Py,fy,doory)   % we ignore landing button presses on Level fy
                  && [exists i:Floor. liftButton(i)] Y(Py,fy,doory)
                  && [exists i:Floor. open(i)] Y(Py,fy,open) 
                  && (forall i:Floor. [Level(i)] Y(Py,i,doory) )
                  && [exists d:Direction. direction(d)] Y(Py,fy,doory)
                  && [close] Y(Py,fy,closed)
                  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy,  doory ) ) )
                  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                  && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy, doory ) ) )
                   )
                 &&
                    ([direction(up)]false)
                 &&
                   (
                     <exists i:Floor. landingButton(i)> true
                  || <exists i:Floor. liftButton(i)> true
                  || <exists i:Floor. open(i)> true
                  || <exists i:Floor. Level(i)> true
                  || <exists d:Direction. direction(d)> true
                  || <close> true
                  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
                   )
                 )
                )
              )
            )
        )
      )
  )
)

&& % and the negation for the complement of products

(mu X (Px:FExpr = normalise( (or(atom(EC), atom(O) ) ) ), fx:Floor = 1, dx:Direction = down, doorx:Door = closed).  % this one yields 'true'
  ( 
  %  translate [true]X
    
     <exists i:Floor. landingButton(i)> X(Px,fx,dx,doorx)
  || <exists i:Floor. liftButton(i)> X(Px,fx,dx,doorx)
  || <exists i:Floor.open(i)> X(Px,fx,dx,open) 
  || (exists i: Floor. <Level(i)> X(Px,i,dx,doorx) )
  || (exists d:Direction. <direction(d)> X(Px,fx,d,doorx) )
  || <close> X(Px,fx,dx,closed)
  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )
  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx,dx,doorx) ) )

  || (val(dx == up) &&
        (
          exists j:Floor. ( val(fx < j && j <= 5) &&
            <liftButton(j)>
              (
                nu Y(Py:FExpr = Px, fy:Floor = fx, doory:Door = doorx). 
                 (
                   !(val(fy == j) )
                 &&
                 (
                 % translate [!open(j)]Y && <true>true 
                   (
                     <!landingButton(fy) && exists i:Floor. landingButton(i)> Y(Py,fy,doory)   % we ignore landing button presses on Level fy
                  || <exists i:Floor. liftButton(i)> Y(Py,fy,doory)
                  || <exists i:Floor. open(i)> Y(Py,fy,open) 
                  || (exists i:Floor. <Level(i)> Y(Py,i,doory) )
                  || <exists d:Direction. direction(d)> Y(Py,fy,doory)
                  || <close> Y(Py,fy,closed)
                  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy,  doory ) ) )
                  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                   )
                 ||
                    (<direction(down)>true)
                 ||
                   (
                     [exists i:Floor. landingButton(i)] false
                  && [exists i:Floor. liftButton(i)] false
                  && [exists i:Floor. open(i)] false
                  && [exists i:Floor. Level(i)] false
                  && [exists d:Direction. direction(d)] false
                  && [close] false
                  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py,e)) == ff)) )
                  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py,e)) == ff)) )
                  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [parking(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [empty(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  )
                 )
                )
              )
            )
        )
      )
 || (val(dx == down) &&
        (
          exists j:Floor. ( val(fx < j && j <= 5) &&
            <liftButton(j)>
              (
                nu Y(Py:FExpr = Px, fy:Floor = fx, doory:Door = doorx). 
                 (
                   !(val(fy == j) )
                 &&
                 (
                 % translate [!open(j)]Y && <true>true 
                   (
                     <!landingButton(fy) && exists i:Floor. landingButton(i)> Y(Py,fy,doory)   % we ignore landing button presses on Level fy
                  || <exists i:Floor. liftButton(i)> Y(Py,fy,doory)
                  || <exists i:Floor. open(i)> Y(Py,fy,open) 
                  || (exists i:Floor. <Level(i)> Y(Py,i,doory) )
                  || <exists d:Direction. direction(d)> Y(Py,fy,doory)
                  || <close> Y(Py,fy,closed)
                  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy,  doory ) ) )
                  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy, doory ) ) )
                   )
                 ||
                    (<direction(up)>true)
                 ||
                   (
                     [exists i:Floor. landingButton(i)] false
                  && [exists i:Floor. liftButton(i)] false
                  && [exists i:Floor. open(i)] false
                  && [exists i:Floor. Level(i)] false
                  && [exists d:Direction. direction(d)] false
                  && [close] false
                  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [parking(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  && (forall e:FExpr. [empty(e)] (val(normalise(and(Py,e)) == ff)) ) 
                  )
                 )
                )
              )
            )
        )
      )
  )
)
 
