% property 1
% AG (landingBut_i.pressed -> AF (lift.Level = i & lift.door = open) )
% invariantly, if a landing button is pressed at Level i, the lift will inevitably open its doors on Level i

%nu X. [true]X && forall i:Floor. [landingButton(i)](mu Y. [!open(i)]Y && <true>true )

% fails exactly when either:
% - executive feature enabled because the lift may ping-pong between two storeys and never stop at the storey in
%   which the landing button is pressed
% - empty carriage feature enabled because someone may play pranks on the elevator by infinitely often pressing
%   and cancelling a lift button
% - overload feature enabled because the lift disables these buttons when an overload is detected

(nu X (Px:FExpr = normalise( neg(or(atom(Ex), or(atom(O),or(atom(TTF),atom(Ex) ) ) ) )), f:Floor = 0).  % this one yields 'true'
  ( 
  %  translate [true]X
    
     [exists i:Floor. landingButton(i)] X(Px,f)
  && [exists i:Floor. liftButton(i)] X(Px,f)
  && (forall i: Floor. [open(i)] X(Px,i) )
  && [exists i:Floor. Level(i)] X(Px,f)
  && [exists d:Direction. direction(d)] X(Px,f)
  && [close] X(Px,f)
  && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [parking(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  && (forall e:FExpr. [empty(e)] (val(normalise(and(Px, and(e,tt))) == ff) || X(normalise(and(Px,and(e,tt))),f) ) )
  
  &&
  % translate forall i:Floor. [landingButton(i)](mu Y. [!open(i)]Y && <true>true )
  forall j:Floor. 
    (
    % translate [landingButton(j)](mu Y. [!open(j)]Y && <true>true )
    [landingButton(j)]
      (
      % translate (mu Y. [!open(j)]Y && <true>true )
      mu Y(Py:FExpr = Px, fy:Floor = f).
        (
        % translate [!open(j)]Y && <true>true 
          (
            [!landingButton(fy) && exists i:Floor. landingButton(i)] Y(Py,fy)   % we ignore landing button presses on Level fy
         && [exists i:Floor. liftButton(i)] Y(Py,fy)
         && (forall i:Floor. [!open(j) && open(i)] Y(Py,i) )
         && [exists i:Floor. Level(i)] Y(Py,fy)
         && [exists d:Direction. direction(d)] Y(Py,fy)
         && [close] Y(Py,fy)
         && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
         && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, and(e,tt))) == ff) || Y(normalise(and(Py,and(e,tt))),fy ) ) )
          )
        &&
          (
            <exists i:Floor. landingButton(i)> true
         || <exists i:Floor. liftButton(i)> true
         || <exists i:Floor. open(i)> true
         || <exists i:Floor. Level(i)> true
         || <exists d:Direction. direction(d)> true
         || <close> true
         || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
         || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) ) )
          )
        )
      )
  
    )
  )
)

&&

% Now for the reverse for the remaining features:
% mu X. <true>X || exists i:Floor. <landingButton(i)>(nu Y. <!open(i)>Y || [true]false )


forall Fx:FExpr.  val(Fx in [atom(Ex), atom(O)]) =>
(mu X (Px:FExpr = normalise( Fx),fx:Floor =0).  % this one yields 'true' (hopefully)
  ( 
  %  translate <true>X
    
     <exists i:Floor. landingButton(i)> X(Px, fx)
  || <exists i:Floor. liftButton(i)> X(Px, fx)
  || (exists i:Floor. <open(i)> X(Px,i) )
  || <exists i:Floor. Level(i)> X(Px, fx)
  || <exists d:Direction. direction(d)> X(Px, fx)
  || <close> X(Px,fx)
  || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Px), e)) == tt) && X(Px,fx) ) )
  
  ||
  % translate exists j:Floor. <landingButton(j)>(nu Y. <!open(j)>Y || [true]false )
  exists j:Floor. 
    (
    % translate <landingButton(j)>(nu Y. <!open(j)>Y || [true]false )
    <landingButton(j)>
      (
      % translate (nu Y. <!open(j)>Y || [true]false )
      nu Y(Py:FExpr = Px, fy:Floor = fx).
        (
        % translate <!open(j)>Y || [true]false 
          (
            <!landingButton(fy) && exists i:Floor. landingButton(i)> Y(Py,fy)
         || <exists i:Floor. liftButton(i)> Y(Py,fy)
         || (exists i:Floor. <!open(j) && open(i)> Y(Py,i) )
         || <exists i:Floor. Level(i)> Y(Py,fy)
         || <exists d:Direction. direction(d)> Y(Py,fy)
         || <close> Y(Py,fy)
         || (exists e:FExpr. <exists i:Floor. executive(e,on,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <executive(e,off)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <exists i:Floor. idling(e,i)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <exists a:Signal. overload(e,a)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <parking(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <ttfull(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
         || (exists e:FExpr. <empty(e)> (val(normalise(or(neg(Py), e)) == tt) && Y(Py,fy) ) )
          )
        ||
          (
            [!landingButton(fy) && exists i:Floor. landingButton(i)] false
         && [exists i:Floor. liftButton(i)] false
         && [exists i:Floor. open(i)] false
         && [exists i:Floor. Level(i)] false
         && [exists d:Direction. direction(d)] false
         && [close] false
         && (forall e:FExpr. [exists i:Floor. executive(e,on,i)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [executive(e,off)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [exists i:Floor. idling(e,i)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [exists a:Signal. overload(e,a)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [parking(e)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [ttfull(e)] (val(normalise(and(Py, e)) == ff)  ) )
         && (forall e:FExpr. [empty(e)] (val(normalise(and(Py, e)) == ff)  ) )
  
          )
        )
      )
  
    )
  )
)
