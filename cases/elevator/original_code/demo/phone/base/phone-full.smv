-- phone-full.smv:  Four complete phones, synchronous


MODULE phone (X,B,C,D,p)
-- parameters: the 4 numbers, and the array of phones
VAR
  dialled : {0,1,2,3,4};
  st      : {idle,dialt,trying,busyt,ringingt,talking,ringing,talked,ended};

ASSIGN
  init(dialled) := 0;
  next(dialled) := case
                    st=idle                : 0;
                    st=dialt & dialled = 0 : {1,2,3,4};
                    1                      : dialled;
                   esac;

  init(st) := idle;
  next(st) := case
      st=idle :
        case
          p[B].st=trying & p[B].dialled=X & next(p[B].st)=ringingt : ringing;
          p[C].st=trying & p[C].dialled=X & next(p[C].st)=ringingt : ringing;
          p[D].st=trying & p[D].dialled=X & next(p[D].st)=ringingt : ringing;
          1                                                   : {idle,dialt};
        esac;

      st=ringing :
        case
          p[B].st=ringingt & p[B].dialled=X & next(p[B].st)=idle : idle;
          p[C].st=ringingt & p[C].dialled=X & next(p[C].st)=idle : idle;
          p[D].st=ringingt & p[D].dialled=X & next(p[D].st)=idle : idle;
          1				             : {ringing,talked};
        esac;

      st=dialt : {dialt,trying};
	       
      st=busyt : {idle,busyt};

      st=trying :
        case
          dialled=B & p[B].st=idle & next(p[B].st)=ringing 
          & ((p[C].st=trying & p[C].dialled=B)->next(p[C].st)=busyt)
          & ((p[D].st=trying & p[D].dialled=B)->next(p[D].st)=busyt) :ringingt;
	  dialled=C & p[C].st=idle & next(p[C].st)=ringing 
	  & ((p[B].st=trying & p[B].dialled=C)->next(p[B].st)=busyt)
	  & ((p[D].st=trying & p[D].dialled=C)->next(p[D].st)=busyt) :ringingt;
          dialled=D & p[D].st=idle & next(p[D].st)=ringing 
          & ((p[B].st=trying & p[B].dialled=D)->next(p[B].st)=busyt)
          & ((p[C].st=trying & p[C].dialled=D)->next(p[C].st)=busyt) :ringingt;
          1							     :busyt;
        esac;

      st=ringingt :
        case
          dialled=B & next(p[B].st)=talked : talking;
          dialled=C & next(p[C].st)=talked : talking;
          dialled=D & next(p[D].st)=talked : talking;
          1                                : {ringingt,idle};
        esac;

      st=talked :
        case
          p[B].st=talking & p[B].dialled=X & next(p[B].st)=idle : ended;
          p[C].st=talking & p[C].dialled=X & next(p[C].st)=idle : ended;
          p[D].st=talking & p[D].dialled=X & next(p[D].st)=idle : ended;
          1                                             : {idle,talked};
        esac;

      st=talking :
        case
          dialled=B & p[B].st=talked & next(p[B].st)=idle : ended;
          dialled=C & p[C].st=talked & next(p[C].st)=idle : ended;
          dialled=D & p[D].st=talked & next(p[D].st)=idle : ended;
          1                                               : {idle,talking};
        esac;

      st=ended : {ended,idle};
   esac;

DEFINE
  party := 
    case
      st=talking                       : dialled;
      p[B].st=talking & p[B].dialled=X : B;
      p[C].st=talking & p[C].dialled=X : C;
      p[D].st=talking & p[D].dialled=X : D;
      1                                : 0;
    esac;

-- Fairness constraints to ensure that a phone does remain in a state
-- indefinitely.  A phone may still alternate between, say, idle <-> dialt.
-- It also seems to slow down smv a little.
FAIRNESS  !st=idle
FAIRNESS  !st=dialt
FAIRNESS  !st=trying
FAIRNESS  !st=busyt
FAIRNESS  !st=ringingt
FAIRNESS  !st=talking
FAIRNESS  !st=ringing
FAIRNESS  !st=talked
FAIRNESS  !st=ended


MODULE main
VAR
  ph[1]	: phone (1,2,3,4,ph);
  ph[2]	: phone (2,1,3,4,ph);
  ph[3]	: phone (3,1,2,4,ph);
  ph[4]	: phone (4,1,2,3,ph);

------
