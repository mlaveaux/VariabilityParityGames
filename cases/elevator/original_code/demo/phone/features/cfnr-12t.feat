-----------------------------------------------------
-- Call Forward on No Reply
-- for reduced-phone.smv
-- all phones apart from ophone (ph[3]) get CFNR
-----------------------------------------------------

FEATURE cfnr-12t
REQUIRE
   MODULE phone1(X,B,C,D,p)
   VAR
     dialled : {0,1,2,3,4};
     st      : {idle,trying,ringingt,ringing};
   MODULE phone2(X,B,C,D,p)
   VAR
     dialled : {0,1,2,3,4};
     st      : {idle,trying,ringingt,ringing};
   MODULE ophone(X,B,C,D,p)
   VAR
     dialled : {0,1,2,3,4};
     st      : {trying,ringingt};
   MODULE tphone(X,B,C,D,p)
   VAR
     st      : {idle,ringing};

INTRODUCE
   MODULE phone1
   VAR forw : {0,2,4};
       nr : boolean;
   ASSIGN
     next(forw):=forw;
     init(nr) := 0;
     next(nr) := case
                   st=ringingt & next(st)=ringingt : 1;
                   st=ringingt : nr;
                   1 : 0;
                 esac;

   MODULE phone2
   VAR forw : {0,1,4};
       nr : boolean;
   ASSIGN
     next(forw):=forw;
     init(nr) := 0;
     next(nr) := case
                   st=ringingt & next(st)=ringingt : 1;
                   st=ringingt : nr;
                   1 : 0;
                 esac;

   MODULE ophone
   VAR nr : boolean;
   ASSIGN
     init(nr) := 0;
     next(nr) := case
                   st=ringingt & next(st)=ringingt : 1;
                   st=ringingt : nr;
                   1 : 0;
                 esac;

   MODULE tphone
   VAR forw : {0,1,2};
   ASSIGN
     next(forw):=forw;

CHANGE
   MODULE phone1  -- don't pick up the phone when CFNR takes over
     IF !forw=0 & st=ringing &
       ( (p[2].st=ringingt & p[2].dialled=1 & p[2].nr)
       | (p[3].st=ringingt & p[3].dialled=1 & p[3].nr))
        THEN IMPOSE next(st) := idle;
   MODULE phone1  -- if phone2 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=2 & !p[2].forw=0
        THEN IMPOSE next(dialled) := p[2].forw;
                    next(st) := trying;
   MODULE phone1  -- if phone4 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=4 & !p[4].forw=0
        THEN IMPOSE next(dialled) := p[4].forw;
                    next(st) := trying;

   MODULE phone2  -- don't pick up the phone when CFNR takes over
     IF !forw=0 & st=ringing &
       ( (p[1].st=ringingt & p[1].dialled=X & p[1].nr)
       | (p[3].st=ringingt & p[3].dialled=X & p[3].nr))
        THEN IMPOSE next(st) := idle;
   MODULE phone2  -- if phone1 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=1 & !p[1].forw=0
        THEN IMPOSE next(dialled) := p[1].forw;
                    next(st) := trying;
   MODULE phone2  -- if phone4 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=4 & !p[4].forw=0
        THEN IMPOSE next(dialled) := p[4].forw;
                    next(st) := trying;

   MODULE ophone  -- if phone1 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=1 & !p[1].forw=0
        THEN IMPOSE next(dialled) := p[1].forw;
                    next(st) := trying;
   MODULE ophone  -- if phone2 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=2 & !p[2].forw=0
        THEN IMPOSE next(dialled) := p[2].forw;
                    next(st) := trying;
   MODULE ophone  -- if phone4 has CFNR and doesn't answer, divert call
     IF st=ringingt & nr & dialled=4 & !p[4].forw=0
        THEN IMPOSE next(dialled) := p[4].forw;
                    next(st) := trying;

   MODULE tphone  -- don't pick up the phone when CFNR takes over
     IF !forw=0 & st=ringing &
       ( (p[1].st=ringingt & p[1].dialled=4 & p[1].nr)
       | (p[2].st=ringingt & p[2].dialled=4 & p[2].nr)
       | (p[3].st=ringingt & p[3].dialled=4 & p[3].nr))
        THEN IMPOSE next(st) := idle;

END
